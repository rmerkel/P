# test/typetest.p, 1: { Test advanced types	}
# test/typetest.p, 2: program typetest;
# test/typetest.p, 3: type
    0: call 0, 2
    1: halt
# test/typetest.p, 4: 	int = integer;
# test/typetest.p, 5: 	rng = 1..10;
# test/typetest.p, 6: 	enum = (	one, two, three	);
# test/typetest.p, 7: 
# test/typetest.p, 8: var
# test/typetest.p, 9: 	i : int;
# test/typetest.p, 10: 	j : integer;
# test/typetest.p, 11: 	r : rng;
# test/typetest.p, 12: 	a : array[rng] of integer;
# test/typetest.p, 13: 	a2 : array [enum] of int;
# test/typetest.p, 14: 	a3 : array [0..4] of array [0..4] of real;
# test/typetest.p, 15: 
# test/typetest.p, 16: begin
    2: enter 41
# test/typetest.p, 17: 	i := 1; i := i + 1;
    3: pushvar 0, 4
    4: push 1
    5: assign 1
    6: pushvar 0, 4
    7: pushvar 0, 4
    8: eval 1
    9: push 1
   10: add
   11: assign 1
# test/typetest.p, 18: 	r := 1; r := r + 1;
   12: pushvar 0, 6
   13: push 1
   14: llimit 1
   15: ulimit 10
   16: assign 1
   17: pushvar 0, 6
   18: pushvar 0, 6
   19: eval 1
   20: push 1
   21: add
   22: llimit 1
   23: ulimit 10
   24: assign 1
# test/typetest.p, 19: 
# test/typetest.p, 20: 	i := 1;	{	fill a[] with its index	}
   25: pushvar 0, 4
   26: push 1
   27: assign 1
# test/typetest.p, 21:  	while i < 11 do begin 
   28: pushvar 0, 4
   29: eval 1
   30: push 11
   31: lt
   32: jneq 65
# test/typetest.p, 22: 		a[i] := i;
   33: pushvar 0, 7
   34: pushvar 0, 4
   35: eval 1
   36: llimit 1
   37: ulimit 10
   38: push 1
   39: sub
   40: add
   41: pushvar 0, 4
   42: eval 1
   43: assign 1
# test/typetest.p, 23: 		writeln(a[i]);
   44: pushvar 0, 7
   45: pushvar 0, 4
   46: eval 1
   47: llimit 1
   48: ulimit 10
   49: push 1
   50: sub
   51: add
   52: eval 1
   53: push 1
   54: push 0
   55: push 0
   56: push 1
   57: writeln
# test/typetest.p, 24: 		i := i + 1
   58: pushvar 0, 4
   59: pushvar 0, 4
   60: eval 1
   61: push 1
# test/typetest.p, 25: 	end;
   62: add
   63: assign 1
   64: jump 28
# test/typetest.p, 26: 
# test/typetest.p, 27: 	r := 1;	{	multiply by 10			}
   65: pushvar 0, 6
   66: push 1
   67: llimit 1
   68: ulimit 10
   69: assign 1
# test/typetest.p, 28: 	repeat begin
# test/typetest.p, 29: 		a[r] := a[r] * 10;
   70: pushvar 0, 7
   71: pushvar 0, 6
   72: eval 1
   73: llimit 1
   74: ulimit 10
   75: push 1
   76: sub
   77: add
   78: pushvar 0, 7
   79: pushvar 0, 6
   80: eval 1
   81: llimit 1
   82: ulimit 10
   83: push 1
   84: sub
   85: add
   86: eval 1
   87: push 10
   88: mul
   89: assign 1
# test/typetest.p, 30: 		writeln(a[r]);
   90: pushvar 0, 7
   91: pushvar 0, 6
   92: eval 1
   93: llimit 1
   94: ulimit 10
   95: push 1
   96: sub
   97: add
   98: eval 1
   99: push 1
  100: push 0
  101: push 0
  102: push 1
  103: writeln
# test/typetest.p, 31: 		r := r + 1
  104: pushvar 0, 6
  105: pushvar 0, 6
  106: eval 1
  107: push 1
# test/typetest.p, 32: 	end until r = 11;
  108: add
  109: llimit 1
  110: ulimit 10
  111: assign 1
  112: pushvar 0, 6
  113: eval 1
  114: push 11
  115: equ
  116: jneq 70
# test/typetest.p, 33: 
# test/typetest.p, 34: 	a2[one]	:= 1;
  117: pushvar 0, 17
  118: push 0
  119: llimit 0
  120: ulimit 2
  121: add
  122: push 1
  123: assign 1
# test/typetest.p, 35: 	a2[two]	:= 2;
  124: pushvar 0, 17
  125: push 1
  126: llimit 0
  127: ulimit 2
  128: add
  129: push 2
  130: assign 1
# test/typetest.p, 36: 	a2[three] := 3;
  131: pushvar 0, 17
  132: push 2
  133: llimit 0
  134: ulimit 2
  135: add
  136: push 3
  137: assign 1
# test/typetest.p, 37: 	writeln(a2[one], a2[two], a2[three]);
  138: pushvar 0, 17
  139: push 0
  140: llimit 0
  141: ulimit 2
  142: add
  143: eval 1
  144: push 1
  145: push 0
  146: push 0
  147: pushvar 0, 17
  148: push 1
  149: llimit 0
  150: ulimit 2
  151: add
  152: eval 1
  153: push 1
  154: push 0
  155: push 0
  156: pushvar 0, 17
  157: push 2
  158: llimit 0
  159: ulimit 2
  160: add
  161: eval 1
  162: push 1
  163: push 0
  164: push 0
  165: push 3
  166: writeln
# test/typetest.p, 38: 
# test/typetest.p, 39: 	i := 0;	{	fill a3[] with it's index	}
  167: pushvar 0, 4
  168: push 0
  169: assign 1
# test/typetest.p, 40: 	while (i < 5) do begin
  170: pushvar 0, 4
  171: eval 1
  172: push 5
  173: lt
  174: jneq 240
# test/typetest.p, 41: 		j := 0;
  175: pushvar 0, 5
  176: push 0
  177: assign 1
# test/typetest.p, 42: 		while (j < 5) do begin
  178: pushvar 0, 5
  179: eval 1
  180: push 5
  181: lt
  182: jneq 231
# test/typetest.p, 43: 			a3[i][j] := 1.0 * (i + j);
  183: pushvar 0, 20
  184: pushvar 0, 4
  185: eval 1
  186: llimit 0
  187: ulimit 4
  188: push 5
  189: mul
  190: add
  191: pushvar 0, 5
  192: eval 1
  193: llimit 0
  194: ulimit 4
  195: add
  196: push 1.000000
  197: pushvar 0, 4
  198: eval 1
  199: pushvar 0, 5
  200: eval 1
  201: add
  202: itor
  203: mul
  204: assign 1
# test/typetest.p, 44: 			write(a3[i][j]);
  205: pushvar 0, 20
  206: pushvar 0, 4
  207: eval 1
  208: llimit 0
  209: ulimit 4
  210: push 5
  211: mul
  212: add
  213: pushvar 0, 5
  214: eval 1
  215: llimit 0
  216: ulimit 4
  217: add
  218: eval 1
  219: push 1
  220: push 0
  221: push 0
  222: push 1
  223: write
# test/typetest.p, 45: 			j := j + 1
  224: pushvar 0, 5
  225: pushvar 0, 5
  226: eval 1
  227: push 1
# test/typetest.p, 46: 		end;
  228: add
  229: assign 1
  230: jump 178
# test/typetest.p, 47: 		writeln;
  231: push 0
  232: writeln
# test/typetest.p, 48: 		i := i + 1
  233: pushvar 0, 4
  234: pushvar 0, 4
  235: eval 1
  236: push 1
# test/typetest.p, 49: 	end
  237: add
  238: assign 1
# test/typetest.p, 50: end .
  239: jump 170
  240: ret

1
2
3
4
5
6
7
8
9
10
10
20
30
40
50
60
70
80
90
100
runtime error @pc 110, sp: 50: out-of-range

# test/typetest.p, 1: { Test advanced types	}
# test/typetest.p, 2: program typetest;
# test/typetest.p, 3: type
    0: call 0, 2
    1: halt
# test/typetest.p, 4: 	int = integer;
# test/typetest.p, 5: 	rng = 1..10;
# test/typetest.p, 6: 	enum = (	one, two, three	);
# test/typetest.p, 7: 
# test/typetest.p, 8: var
# test/typetest.p, 9: 	i : int;
# test/typetest.p, 10: 	j : integer;
# test/typetest.p, 11: 	r : rng;
# test/typetest.p, 12: 	a : array[rng] of integer;
# test/typetest.p, 13: 	a2 : array [enum] of int;
# test/typetest.p, 14: 	a3 : array [0..4] of array [0..4] of real;
# test/typetest.p, 15: 
# test/typetest.p, 16: begin
    2: enter 41
# test/typetest.p, 17: 	i := 1; i := i + 1;
    3: pushvar 0, 4
    4: push 1
    5: assign 1
    6: pushvar 0, 4
    7: pushvar 0, 4
    8: eval 1
    9: push 1
   10: add
   11: assign 1
# test/typetest.p, 18: 	r := 1; r := r + 1;
   12: pushvar 0, 6
   13: push 1
   14: llimit 1
   15: ulimit 10
   16: assign 1
   17: pushvar 0, 6
   18: pushvar 0, 6
   19: eval 1
   20: push 1
   21: add
   22: llimit 1
   23: ulimit 10
   24: assign 1
# test/typetest.p, 19: 
# test/typetest.p, 20: 	i := 1;	{	fill a[] with its index	}
   25: pushvar 0, 4
   26: push 1
   27: assign 1
# test/typetest.p, 21:  	while i < 11 do begin 
   28: pushvar 0, 4
   29: eval 1
   30: push 11
   31: lt
   32: jneq 64
# test/typetest.p, 22: 		a[i] := i;
   33: pushvar 0, 7
   34: pushvar 0, 4
   35: eval 1
   36: llimit 1
   37: ulimit 10
   38: push 1
   39: sub
   40: add
   41: pushvar 0, 4
   42: eval 1
   43: assign 1
# test/typetest.p, 23: 		writeln(a[i]);
   44: pushvar 0, 7
   45: pushvar 0, 4
   46: eval 1
   47: llimit 1
   48: ulimit 10
   49: push 1
   50: sub
   51: add
   52: eval 1
   53: push 0
   54: push 0
   55: push 1
   56: writeln
# test/typetest.p, 24: 		i := i + 1
   57: pushvar 0, 4
   58: pushvar 0, 4
   59: eval 1
   60: push 1
# test/typetest.p, 25: 	end;
   61: add
   62: assign 1
   63: jump 28
# test/typetest.p, 26: 
# test/typetest.p, 27: 	r := 1;	{	multiply by 10			}
   64: pushvar 0, 6
   65: push 1
   66: llimit 1
   67: ulimit 10
   68: assign 1
# test/typetest.p, 28: 	repeat begin
# test/typetest.p, 29: 		a[r] := a[r] * 10;
   69: pushvar 0, 7
   70: pushvar 0, 6
   71: eval 1
   72: llimit 1
   73: ulimit 10
   74: push 1
   75: sub
   76: add
   77: pushvar 0, 7
   78: pushvar 0, 6
   79: eval 1
   80: llimit 1
   81: ulimit 10
   82: push 1
   83: sub
   84: add
   85: eval 1
   86: push 10
   87: mul
   88: assign 1
# test/typetest.p, 30: 		writeln(a[r]);
   89: pushvar 0, 7
   90: pushvar 0, 6
   91: eval 1
   92: llimit 1
   93: ulimit 10
   94: push 1
   95: sub
   96: add
   97: eval 1
   98: push 0
   99: push 0
  100: push 1
  101: writeln
# test/typetest.p, 31: 		r := r + 1
  102: pushvar 0, 6
  103: pushvar 0, 6
  104: eval 1
  105: push 1
# test/typetest.p, 32: 	end until r = 11;
  106: add
  107: llimit 1
  108: ulimit 10
  109: assign 1
  110: pushvar 0, 6
  111: eval 1
  112: push 11
  113: equ
  114: jneq 69
# test/typetest.p, 33: 
# test/typetest.p, 34: 	a2[one]	:= 1;
  115: pushvar 0, 17
  116: push 0
  117: llimit 0
  118: ulimit 2
  119: add
  120: push 1
  121: assign 1
# test/typetest.p, 35: 	a2[two]	:= 2;
  122: pushvar 0, 17
  123: push 1
  124: llimit 0
  125: ulimit 2
  126: add
  127: push 2
  128: assign 1
# test/typetest.p, 36: 	a2[three] := 3;
  129: pushvar 0, 17
  130: push 2
  131: llimit 0
  132: ulimit 2
  133: add
  134: push 3
  135: assign 1
# test/typetest.p, 37: 	writeln(a2[one], a2[two], a2[three]);
  136: pushvar 0, 17
  137: push 0
  138: llimit 0
  139: ulimit 2
  140: add
  141: eval 1
  142: push 0
  143: push 0
  144: pushvar 0, 17
  145: push 1
  146: llimit 0
  147: ulimit 2
  148: add
  149: eval 1
  150: push 0
  151: push 0
  152: pushvar 0, 17
  153: push 2
  154: llimit 0
  155: ulimit 2
  156: add
  157: eval 1
  158: push 0
  159: push 0
  160: push 3
  161: writeln
# test/typetest.p, 38: 
# test/typetest.p, 39: 	i := 0;	{	fill a3[] with it's index	}
  162: pushvar 0, 4
  163: push 0
  164: assign 1
# test/typetest.p, 40: 	while (i < 5) do begin
  165: pushvar 0, 4
  166: eval 1
  167: push 5
  168: lt
  169: jneq 234
# test/typetest.p, 41: 		j := 0;
  170: pushvar 0, 5
  171: push 0
  172: assign 1
# test/typetest.p, 42: 		while (j < 5) do begin
  173: pushvar 0, 5
  174: eval 1
  175: push 5
  176: lt
  177: jneq 225
# test/typetest.p, 43: 			a3[i][j] := 1.0 * (i + j);
  178: pushvar 0, 20
  179: pushvar 0, 4
  180: eval 1
  181: llimit 0
  182: ulimit 4
  183: push 5
  184: mul
  185: add
  186: pushvar 0, 5
  187: eval 1
  188: llimit 0
  189: ulimit 4
  190: add
  191: push 1.000000
  192: pushvar 0, 4
  193: eval 1
  194: pushvar 0, 5
  195: eval 1
  196: add
  197: itor
  198: mul
  199: assign 1
# test/typetest.p, 44: 			write(a3[i][j]);
  200: pushvar 0, 20
  201: pushvar 0, 4
  202: eval 1
  203: llimit 0
  204: ulimit 4
  205: push 5
  206: mul
  207: add
  208: pushvar 0, 5
  209: eval 1
  210: llimit 0
  211: ulimit 4
  212: add
  213: eval 1
  214: push 0
  215: push 0
  216: push 1
  217: write
# test/typetest.p, 45: 			j := j + 1
  218: pushvar 0, 5
  219: pushvar 0, 5
  220: eval 1
  221: push 1
# test/typetest.p, 46: 		end;
  222: add
  223: assign 1
  224: jump 173
# test/typetest.p, 47: 		writeln;
  225: push 0
  226: writeln
# test/typetest.p, 48: 		i := i + 1
  227: pushvar 0, 4
  228: pushvar 0, 4
  229: eval 1
  230: push 1
# test/typetest.p, 49: 	end
  231: add
  232: assign 1
# test/typetest.p, 50: end .
  233: jump 165
  234: ret

1
2
3
4
5
6
7
8
9
10
10
20
30
40
50
60
70
80
90
100
runtime error @pc 108, sp: 50: out-of-range
